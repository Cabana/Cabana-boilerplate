require 'JSON'
require 'pp'
require 'colorize'
require 'closure-compiler'
require 'fileutils'
require 'httparty'
require_relative 'config'

@js_build_filename    ||= 'app.js'
@css_build_dir        ||= '../resources/css'
@js_build_dir         ||= '../resources/js'
@img_build_dir        ||= '../resources/img'
@fonts_build_dir      ||= '../resources/fonts'
@export_dir           ||= '../export'
@js_components        ||= []
@js_compression_level ||= 'SIMPLE_OPTIMIZATIONS'
@replacements         ||= {}

directory @css_build_dir
directory @js_build_dir
directory @img_build_dir
directory @fonts_build_dir

task default: :build

desc 'Build all resources'
task build: [
  'build:css',
  'build:js',
  'build:fonts',
  'build:img'
] do
  puts 'Resources have been built!'.magenta
  Dir[File.join(@css_build_dir, "*.css")].each do |css_file|
    puts "#{css_file.split(File::SEPARATOR).last} is now #{file_size_in_kb(css_file)} kb"
  end
  Dir[File.join(@js_build_dir, "*.js")].each do |js_file|
    puts "#{js_file.split(File::SEPARATOR).last} is now #{file_size_in_kb(js_file)} kb"
  end
end

namespace :build do
  desc "Build all resources and make them ready for deployment"
  task for_deploy: [
    'build',
    'replace_paths',
    'remove:console.log'
  ] do
    puts 'Resources are now ready for deployment'.magenta
  end

  desc 'Build css'
  task css: [@css_build_dir] do
    system "compass compile --css-dir #{@css_build_dir} --force"
  end

  desc 'Minify and concatenate js'
  task js: [@js_build_dir] do
    contents = Closure::Compiler.new(compilation_level: @js_compression_level).compile_files @js_components
    File.open "#{@js_build_dir}/#{@js_build_filename}", "w" do |file|
      file.write contents
    end
    puts "overwrite".yellow + " #{@js_build_dir}/#{@js_build_filename}"
  end

  desc 'Copy images'
  task img: [@img_build_dir] do
    Dir.glob(File.join(@img_build_dir, "**", "*")).each do |file|
      FileUtils.rm_r file
    end
    img_paths.each {|ip| FileUtils.copy_file ip, "#{@img_build_dir}/#{ip.gsub('img/', '')}" }
    puts "Copied images".yellow
  end

  desc 'Copy fonts'
  task fonts: [@fonts_build_dir] do
    remove_files_in @fonts_build_dir
    font_paths.each {|fp| FileUtils.copy_file fp, "#{@fonts_build_dir}/#{fp.gsub('fonts/', '')}" }
  end
end

desc "Replace paths"
task :replace_paths do
  if @replacements.size > 0
    @replacements.each do |path, replacements|
      number_of_matches = 0
      replacements.each do |replacement|
        replace replacement[:replace], with: replacement[:with], in_file: path
        number_of_matches += File.open(path, 'r').read.scan(replacement[:with]).size
      end
      puts "Replaced #{replacements.size} path(s) in #{path.split(File::SEPARATOR).last}, #{number_of_matches} replacements total".yellow
    end
  else
    puts "No paths to replace".yellow
  end
end

desc "Build and export project to path"
task export: ['build:for_deploy'] do |t|
  export_folder_path = File.join(File.expand_path("..", Dir.pwd), "export")

  # remove the export folder and destination folder if they exist
  FileUtils.rm_r @export_dir if File.exists?(@export_dir)
  FileUtils.rm_r export_folder_path if File.exists?(export_folder_path)

  # make the export folder
  FileUtils.mkdir export_folder_path

  # compile php files into html and place them in the export folder
  if folder_contains_php? File.expand_path('..')
    compile_php_files_into export_folder_path
  end

  # copy each html file into the export folder
  Dir[File.join(File.expand_path(".."), '*.html')].each do |file|
    filename = File.basename(file)
    FileUtils.copy_file file, File.join(export_folder_path, filename)
  end

  # copy the resources folder into the export folder
  FileUtils.cp_r File.join(File.expand_path(".."), 'resources'), File.join(export_folder_path, 'resources')

  # copy the export folder to the specified path
  cp_r export_folder_path, @export_dir

  # remove the export folder from the project
  FileUtils.rm_r export_folder_path
end

namespace :remove do
  desc "Remove console.log statements from #{@js_build_filename}"
  task "console.log" do
    file_path = File.join(@js_build_dir, @js_build_filename)
    number_of_matches = File.open(file_path, 'r').read.scan(/console\.log\(.+?\);?/).size
    if number_of_matches > 0
      replace /console\.log\(.+?\);?/, with: '', in_file: file_path
      puts "Removed #{number_of_matches} console.logs".yellow
    else
      puts "No console.logs to replace".yellow
    end
  end
end

def replace pattern, hash = {}
  file_path = hash[:in_file]
  with = hash[:with]

  contents = File.read file_path if File.exists? file_path
  contents.gsub!(pattern, with)
  File.open file_path, "w" do |file|
    file.write contents
  end
end

def compile_php_files_into folder_path
  project_path = File.expand_path("..")
  current_project = project_path.split(File::SEPARATOR).last

  if File.exists?('/Volumes/inetpub/Cabana/Kunder/wwwroot/frontend')
    tmp_dir = '/Volumes/inetpub/Cabana/Kunder/wwwroot/frontend'
  elsif File.exists?('I:\Cabana\Kunder\wwwroot\frontend')
    tmp_dir = 'I:\Cabana\Kunder\wwwroot\frontend'
  else
    puts "Could not find the the frontend folder on the I drive".red
    exit
  end

  cp_r project_path, tmp_dir

  Dir[File.join(File.expand_path(".."), '*.php')].each do |php_file|
    php_file = php_file.split(File::SEPARATOR).last
    file = File.new(File.join(folder_path, php_file.gsub('php', 'html')), "w")
    file.puts HTTParty.get("http://kunder.cabana.dk/frontend/#{current_project}/#{php_file}").body
    file.close
  end

  FileUtils.rm_r File.join(tmp_dir, current_project)
end

def file_size_in_kb file_path
  File.size(file_path)./(1024.0).round
end

def font_paths
  Dir["fonts/**/*"].map {|path| path unless path.include?("config.json") }.compact
end

def img_paths
  Dir["img/**/*"]
end

def remove_files_in folder_path
  Dir["#{folder_path}/**/*"].each {|file| FileUtils.rm_rf file }
end

def folder_contains_php? folder
  true if Dir["#{folder}/*.php"].length > 0
end

def folder_contains_php? folder
  true if Dir["#{folder}/*.php"].length > 0
end

Kernel.trap("EXIT") do
  @run_on_exit.call
end
